using System.Numerics;
using System;
using UnityEngine;
using System.Collections.Generic;

public class Platform : MonoBehaviour
{
    public float alpha;
    public float beta_real;
    public float beta_imag;
    Complex beta;
    public float gamma;

    public GameObject sphere;

    // To Do: make these hidden and generated by start method
    public GameObject planeCircle;
    public GameObject planeLine;
    GameObject sphereCircle;

    public GameObject tempo;
    public GameObject tempp;
    public GameObject tempq;
    public GameObject tempc;
    public GameObject tempn;
    public GameObject v2;
    public GameObject v3;

    public Material lineMaterial;
    public int segments = 100;
    public int phiResolution = 100;
    public int thetaResolution = 100;
    public bool isBowl = true;
    Mesh mesh;
    public float thetaUpper;
    public float thetaLower;

    private UnityEngine.Vector3 ParamOfSurface(double phi, double theta, double rs, UnityEngine.Vector3 cs)
    {
        return new UnityEngine.Vector3((float)(rs * Math.Sin(theta) * Math.Sin(phi)), (float)(rs * Math.Cos(theta)), (float)(rs * Math.Sin(theta) * Math.Cos(phi))) + cs;
    }

    private void RenderSpherePlatform(UnityEngine.Vector3 cs, UnityEngine.Vector3 n, double rs, UnityEngine.Vector3 c2, double r2)
    {
        // need to determine whether rendering cap or bowl
        double phiLower = 0;
        double phiUpper = 2 * Math.PI;
        double phiStep = (phiUpper - phiLower) / phiResolution;

        //double thetaLower;
        //double thetaUpper;
        //if (isBowl)
        //{
        //    thetaLower = Math.Atan2(Math.Abs((c2 - cs).y), r2);
        //    thetaUpper = Math.PI;
        //}
        //else
        //{
        //    thetaLower = 0;
        //    thetaUpper = Math.Atan2((c2 - cs).y, r2);
        //}
        double thetaStep = (thetaUpper - thetaLower) / thetaResolution;

        List<UnityEngine.Vector3> vertices = new List<UnityEngine.Vector3>();
        n = n.normalized;
        UnityEngine.Quaternion rotation = UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3.up, n);

        for (double theta = thetaLower; theta <= thetaUpper; theta += thetaStep)
        {
            if (theta == 0 || theta == Math.PI)
            {
                UnityEngine.Vector3 translatedVertex = ParamOfSurface(0, theta, rs, cs) - cs;
                translatedVertex = rotation * translatedVertex;
                vertices.Add(translatedVertex + cs);
            }
            else
            {
                for (double phi = phiLower; phi <= phiUpper; phi += phiStep)
                {
                    UnityEngine.Vector3 translatedVertex = ParamOfSurface(phi, theta, rs, cs) - cs;
                    translatedVertex = rotation * translatedVertex;
                    vertices.Add(translatedVertex + cs);
                }
            }
        }


        List<int> triangles = new List<int>();

        if (isBowl)
        {
            for (int j = 1; j <= phiResolution; j++) {
                triangles.Add(0);
                triangles.Add(j);
                triangles.Add(j % phiResolution + 1);
            }

            for (int k = 1; k < thetaResolution; k++)
            {
                for (int j = 1; j <= phiResolution; j++)
                {
                    triangles.Add((k - 1) * phiResolution + j);
                    triangles.Add(k * phiResolution + j);
                    triangles.Add(k * phiResolution + j % phiResolution + 1);

                    triangles.Add((k - 1) * phiResolution + j);
                    triangles.Add(k * phiResolution + j % phiResolution + 1);
                    triangles.Add((k - 1) * phiResolution + j + 1);
                }
            }
        }
        mesh.Clear();
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
    }
    private void RenderCircleOutline(UnityEngine.Vector3 center, UnityEngine.Vector3 normal, double radius)
    {
        LineRenderer lineRenderer = sphereCircle.GetComponent<LineRenderer>();

        lineRenderer.material = lineMaterial;
        lineRenderer.widthMultiplier = 0.1f;
        lineRenderer.loop = true;
        lineRenderer.positionCount = segments + 1;

        // Generate circle points
        UnityEngine.Vector3[] circlePoints = new UnityEngine.Vector3[segments + 1];
        UnityEngine.Vector3 axis1, axis2;
        GetPerpendicularAxes(normal, out axis1, out axis2);

        for (int i = 0; i <= segments; i++)
        {
            float angle = (i * 2 * Mathf.PI) / segments;
            UnityEngine.Vector3 point = center + (float)radius * (Mathf.Cos(angle) * axis1 + Mathf.Sin(angle) * axis2);
            circlePoints[i] = point;
        }

        lineRenderer.SetPositions(circlePoints);
    }

    private void GetPerpendicularAxes(UnityEngine.Vector3 normal, out UnityEngine.Vector3 axis1, out UnityEngine.Vector3 axis2)
    {
        normal.Normalize();
        axis1 = UnityEngine.Vector3.Cross(normal, UnityEngine.Vector3.up);
        if (axis1.magnitude < 0.001f)
        {
            axis1 = UnityEngine.Vector3.Cross(normal, UnityEngine.Vector3.right);
        }
        axis1.Normalize();
        axis2 = UnityEngine.Vector3.Cross(normal, axis1).normalized;
    }

    private UnityEngine.Vector3 CalcCircleCentreFromPoints(UnityEngine.Vector3 o2, UnityEngine.Vector3 p2, UnityEngine.Vector3 q2)
    {
        UnityEngine.Vector3 n = UnityEngine.Vector3.Cross(p2 - o2, q2 - o2);

        // Following code solves linear system Ax = b where x is centre of circle
        double b1 = UnityEngine.Vector3.Dot(p2, n);
        double b2 = 0.5 * (p2.sqrMagnitude - o2.sqrMagnitude);
        double b3 = 0.5 * (q2.sqrMagnitude - o2.sqrMagnitude);

        double[,] A =
        {
                { n.x, n.y, n.z },
                { p2.x - o2.x, p2.y - o2.y, p2.z - o2.z },
                { q2.x - o2.x, q2.y - o2.y, q2.z - o2.z }
            };
        // Calculate determinant of A
        double detA = A[0, 0] * (A[1, 1] * A[2, 2] - A[1, 2] * A[2, 1])
                   - A[0, 1] * (A[1, 0] * A[2, 2] - A[1, 2] * A[2, 0])
                   + A[0, 2] * (A[1, 0] * A[2, 1] - A[1, 1] * A[2, 0]);

        if (Mathf.Abs((float)detA) < 1e-10)
        {
            Debug.LogError("Matrix is not invertible.");
            return new UnityEngine.Vector3(0,0,0);
        }

        // Calculate inverse of A
        double invDetA = 1.0 / detA;
        double[,] AInv = new double[3, 3];
        AInv[0, 0] = invDetA * (A[1, 1] * A[2, 2] - A[1, 2] * A[2, 1]);
        AInv[0, 1] = invDetA * (A[0, 2] * A[2, 1] - A[0, 1] * A[2, 2]);
        AInv[0, 2] = invDetA * (A[0, 1] * A[1, 2] - A[0, 2] * A[1, 1]);
        AInv[1, 0] = invDetA * (A[1, 2] * A[2, 0] - A[1, 0] * A[2, 2]);
        AInv[1, 1] = invDetA * (A[0, 0] * A[2, 2] - A[0, 2] * A[2, 0]);
        AInv[1, 2] = invDetA * (A[0, 2] * A[1, 0] - A[0, 0] * A[1, 2]);
        AInv[2, 0] = invDetA * (A[1, 0] * A[2, 1] - A[1, 1] * A[2, 0]);
        AInv[2, 1] = invDetA * (A[0, 1] * A[2, 0] - A[0, 0] * A[2, 1]);
        AInv[2, 2] = invDetA * (A[0, 0] * A[1, 1] - A[0, 1] * A[1, 0]);

        // Multiply AInv by b to get x
        double cx = AInv[0, 0] * b1 + AInv[0, 1] * b2 + AInv[0, 2] * b3;
        double cy = AInv[1, 0] * b1 + AInv[1, 1] * b2 + AInv[1, 2] * b3;
        double cz = AInv[2, 0] * b1 + AInv[2, 1] * b2 + AInv[2, 2] * b3;

        UnityEngine.Vector3 c2 = new UnityEngine.Vector3((float)cx, (float)cy, (float)cz);

        tempc.transform.position = c2;
        return c2;
    }

    private UnityEngine.Vector3 ProjectPlaneToSphere(UnityEngine.Vector3 p)
    {
        UnityEngine.Vector3 cs = sphere.transform.position;
        double rs = sphere.transform.localScale.x / 2;
        UnityEngine.Vector3 N = cs + new UnityEngine.Vector3(0, (float)rs, 0); // north pole

        double lambda = -2 * rs * (p.y - cs.y - rs) / (Math.Pow(p.x - cs.x, 2) + Math.Pow(p.y - cs.y - rs, 2) + Math.Pow(p.z - cs.z, 2));

        return (p - N) * (float)lambda + N;
    }

    private void SetSpherePlatform()
    {
        UnityEngine.Vector3 cs = sphere.transform.position;
        double rs = sphere.transform.localScale.x / 2;

        Complex centre = -beta / alpha;
        double r1 = Math.Sqrt(1 / alpha * (Math.Pow(beta.Magnitude, 2) - gamma));
        UnityEngine.Vector3 c1 = new UnityEngine.Vector3((float)centre.Real, 0, (float)centre.Imaginary);

        if (alpha != 0)
        {
            UnityEngine.Vector3 o1 = c1 + new UnityEngine.Vector3(0, 0, (float)r1);
            UnityEngine.Vector3 p1 = c1 + new UnityEngine.Vector3((float)r1, 0, 0);
            UnityEngine.Vector3 q1 = c1 - new UnityEngine.Vector3((float)r1, 0, 0);

            UnityEngine.Vector3 o2 = ProjectPlaneToSphere(o1);
            UnityEngine.Vector3 p2 = ProjectPlaneToSphere(p1);
            UnityEngine.Vector3 q2 = ProjectPlaneToSphere(q1);

            tempo.transform.position = o2;
            tempp.transform.position = p2;
            tempq.transform.position = q2;

            UnityEngine.Vector3 c2 = CalcCircleCentreFromPoints(o2, p2, q2);
            double r2 = (p2 - c2).magnitude;
            UnityEngine.Vector3 n = UnityEngine.Vector3.Cross(p2 - o2, q2 - o2);

            RenderCircleOutline(c2, n, r2);
            RenderSpherePlatform(cs, n, rs, c2, r2);
        }
        else
        {
            // TODO: fix when line

            UnityEngine.Vector3 o1 = c1 + new UnityEngine.Vector3(0, 0, (float)r1);
            
            UnityEngine.Vector3 o2 = ProjectPlaneToSphere(o1);
            UnityEngine.Vector3 p2 = cs + new UnityEngine.Vector3(0, (float)rs, 0);
            UnityEngine.Vector3 q2 = cs - new UnityEngine.Vector3(0, (float)rs, 0);

            UnityEngine.Vector3 c2 = CalcCircleCentreFromPoints(o2, p2, q2);
            double r2 = rs;
            UnityEngine.Vector3 n = UnityEngine.Vector3.Cross(p2 - o2, q2 - o2);

            tempo.transform.position = o2;
            tempp.transform.position = p2;
            tempq.transform.position = q2;
            tempn.transform.position = n;

            RenderCircleOutline(c2, n, r2);
        }
    }
    private void SetPlanePlatform()
    {
        beta = new Complex(beta_real, beta_imag);

        if (alpha != 0) // platform is a circle
        {
            // for circle |z - c| = r
            double radius = Math.Sqrt(1 / alpha * (Math.Pow(beta.Magnitude, 2) - gamma));
            Complex centre = -beta / alpha;

            planeCircle.transform.position = new UnityEngine.Vector3((float)centre.Real, 0f, (float)centre.Imaginary);
            // default cylinder radius is 0.5 so for radius of x set scale to 2x
            planeCircle.transform.localScale = new UnityEngine.Vector3((float)(2 * radius), 0.1f, (float)(2 * radius));

            planeLine.SetActive(false);
            planeCircle.SetActive(true);
        }
        else // platform is a line
        {
            // for line ax + bz + c = 0
            double a = 2 * beta.Real;
            double b = 2 * beta.Imaginary;
            double c = gamma;

            double angle = Math.Atan2((float)b, (float)a) * Mathf.Rad2Deg;
            planeLine.transform.rotation = UnityEngine.Quaternion.Euler(0, (float)angle, 0);

            planeLine.SetActive(true);
            planeCircle.SetActive(false);
        }
    }
    void Start()
    {
        beta = new Complex(beta_real, beta_imag);
        sphereCircle = new GameObject("sphereCircle");
        sphereCircle.AddComponent<LineRenderer>();
        mesh = new Mesh();
        GetComponent<MeshFilter>().mesh = mesh;
    }

    void Update()
    {
        SetPlanePlatform();
        SetSpherePlatform();
    }
}
